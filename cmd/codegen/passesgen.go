package main

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"text/template"
)

type CheckConfig struct {
	Checks []string `json:"checks"`
}

const Template = `// Package passes Creates analysers for go/analysis
// Code generated by go generate; DO NOT EDIT.
// This file was generated by passesgen.go
package passes

import (
	"golang.org/x/tools/go/analysis"
    {{range .Checks}}
        "golang.org/x/tools/go/analysis/passes/{{.}}"
    {{end}}
)

func GetAnalysers() []*analysis.Analyzer{
    analyzers := make([]*analysis.Analyzer, 0)
    {{range .Checks}}
        analyzers = append(analyzers, {{.}}.Analyzer)
    {{end}}

    return analyzers
}`

func generatePasses() error {

	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		return fmt.Errorf("could not get filename")
	}

	dir := filepath.Dir(filename)

	file, err := os.Open(filepath.Join(dir, "passes.conf"))
	if err != nil {
		return err
	}

	defer func() {
		err = file.Close()
		if err != nil {
			fmt.Printf("Failed to close config file: %v\n", err)
		}
	}()

	data, err := io.ReadAll(file)
	if err != nil {
		return err
	}

	var config CheckConfig
	if err = json.Unmarshal(data, &config); err != nil {
		return err
	}

	t := template.Must(template.New("pases").Parse(Template))

	// Move two directories up.
	parentDir := filepath.Dir(filepath.Dir(dir))

	const perms = 0644
	out, err := os.OpenFile(filepath.Join(parentDir, "internal/codegen/passes/passes.go"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perms)
	if err != nil {
		return err
	}

	defer func() {
		err = out.Close()
		if err != nil {
			fmt.Printf("Failed to close output file: %v\n", err)
		}
	}()

	err = t.Execute(out, config)
	if err != nil {
		return err
	}

	return nil
}

func main() {
	err := generatePasses()
	if err != nil {
		fmt.Printf("Failed to generate passes: %v\n", err)
	}
}
